package jpabook.japshop.domain.전체적개념설명;

public class 연관관계 {
    /**
     *
     * 연관관계 맵핑할 때 고려해야할 것들
     * 1. 다중성
     * 2. 단방향 , 양방향
     * 3. 연관관계의 주인
     *
     * 다 대 다 는 사용 안하는 것이 제일 좋다.
     *
     * Table
     * 1. 외래키 하나로 양쪽 조인 가능
     * 2. 방향이라는 개념이 존재하지 않음
     *
     * Object
     * 1. 참조용 필드가 있는 쪽만 참조 가능
     * 2. 한쪽만 참조하면 단방향
     * 3. 양쪽이 서로 참조하면 양방향 => 단방향이 2개 인 것 단방향입니다 원래는
     *
     * 연관관계의 주인
     * Object
     * A -> B B -> A 참조가 두군데
     * 테이블 외래키 관리 지정
     * 외래키를 관리하는 참조
     * 주인의 반대편 : 조회만 가능
     *
     * N:1 다대일 제일 중요
     * DB
     * N : 1 일 때 N 의 테이블에 FK 가 존재해야 합니다.
     *
     * 1 : N 일 대 다
     * 객체 입장에는 가능한데,
     * db 설계상 fk 는 다에 존재해야하고,
     * 그럼 N 에 1의 테이블 PK 가 FK 로 존재해야 한다.
     * 그렇게 되면 ?
     * 연관관계 주인이 Team 에 있는데, Member에 있어아 하는 것과 대조되게 된다.
     * 따라서, 설계 상으로 좋지 않다.
     *
     * 좋은 연관관계 설계
     * 연관관계의 주인이 N에 존재
     * @ManyToOne
     * @JoinColumn("")
     *
     * 나쁜 연관관계 설계
     * 연관관계의 주인이 1에 존재
     * @OneToMany
     * @JoinColum("")
     * 이렇게 되면 ,
     * Insert 하고, Update Query 를 한번 더 날려야하는 상황이 되는데,
     * 그 이유는 외래키가 N 에 존재하기 때문과,
     * team.getMembers().add(member);
     * 를 실행 할 때 Update 문이 한번 더 나가게 된다.
     *
     * 성능상 큰 이슈는 되지 않지만, 손해
     *
     * 2번째 이유
     * Team 객체를 조정 했는데,
     * Member table 을 연이어서 Update 가 나가게 되는 상황이
     * 많이 꼬였을 때, 좋지 않음.
     *
     * 이럴 때 해결방안,
     * 다 대 일 양방향 처럼 변경하면 된다.
     *
     * 주의 할 점
     * @JoinColumn 을 넣지않으면 조인 테이블 방식을 사용하게 되서 쓸 대 없는 테이블이
     * 생성된다.
     * 장점이 있지만, 운영 , 성능 상 단점이 존재한다.
     * default = > join table create
     *
     * 일 대 다 보다는 좀 손해 보더라도 다 대 일 양방향을 사용할 것,
     *
     *
     * 일대다 양방향 사용시
     * N 의 객체에 연관관계 주인처럼 만든 다음
     * @ManyToOne
     * @JoinColum(name = "" , insertable = false , updatable = false)
     * 1의 객체에
     * @OneToMany
     * @JoinColum(name = "")
     *
     * 을 만드는데,
     * insertable - false 인설트문 처리 하지 않고,
     * updatable - false 업데이트 문 처리를 하지 않아서
     * readOnly 상태로 만든다.
     *
     *
     *
     * 1:1 관계
     *
     * 주테이블 관계나 대상 테이블 중에 외래키를 선택할 수 있음.
     * 아무 거나 둘다 가능하다는 뜻
     *
     * 외래키에 데이터베이스 유니크 제약조건을 사용해야함.
     *
     * 항상 개발자는
     * trade off 에 대해 고민하고 설계해야 한다.
     * 객체지향을 할 때에는 주 테이블에 외래키
     * 대상 테이블 할 때에는 DBA 입장에서 미래를 봤을 때 변경 ,
     * 단지 주 테이블에 외래키가 있을 때에는 null 을 허용해야하고,
     * 대상 테이블일 경우에는 JPA 설계상 양방향으로 설계해야하는 단점이 있다. 또한
     * 지연로딩으로 설정해도 즉시 로딩이 된다.
     *
     * 지연로딩은 좋은 건데 왜~!~!
     * 프록시 활용이 어렵다.
     * Member locker 를 조회 할 때 locker 를 뒤져야하는데,
     * 이렇게 되면 서브 쿼리를 사용해서 exist 할 때처럼 확인해야함.
     * 그렇기 때문에 프록시로 만들 필요가 없게 되고 즉시로딩이 된다.
     *
     * 프록시 객체 경우에는
     * 값이나 null 을 넣어야하는데 이미 쿼리를 넣어야 확인 할 수 있기 때문에
     * 결국 지연로딩을 하지 않고 바로 쿼리를 날리는 형태로 가는 것
     *
     * 이 단점은 크다.
     *
     * N : M 실무에선 안쓰니깐
     * 쓰지마시오.
     * RDB 에서는 조인테이블을 생성하여 N : M 관계를 만든다.
     * 관계테이블을 생성한다는 것
     *
     *
     * 객체 - > 컬렉션을 활용하기에 다대다 관계 가능 하다.
     * @ManyToMany 사용
     *
     * 편해보이는데, 문제점이 있다.
     *
     * 연결테이블은 단순히 연결만 하겠다는 것이 아니다.
     * 주문 시간 , 수량 같은 데이터가 들어가는데,
     * 그 것 을 활용 할 수 없다.
     * 따라서 활용하기 힘들다.
     *
     * query 가 중간테이블 활용하고 조인해서 나와야해서 query 가 이상하게 나옴
     *
     * 해결방안
     *
     * 중간테이블을 객체(Entity) 로 만들고
     * @OneToMany , @ManyToOne 을 사용해서 만든다.
     * Member = MemberProduct = Product 를 체크하면 된다.
     *
     *
     */
}
